4.8读论文

# ByteTrack 算法原理

ByteTrack 是基于 tracking-by-detection 范式的跟踪方法。作者提出了一种简单高效的数据关联方法 BYTE。它和之前跟踪算法的最大区别在于，**并不是简单的去掉低分检测结果**，而是“Assiciating Every Detection Box”。利用检测框和跟踪轨迹之间的相似性，在保留高分检测结果的同时，从低分检测结果中去除背景，挖掘出真正的物体（遮挡、模糊等困难样本），从而降低漏检并提高轨迹的连贯性。速度到 30 FPS，各项指标（准确率，FPS等）均有突破。


前面提到作者保留了低分检测框，其他文章直接当做高分检测框处理显然是不合理的，那样会带来很多背景（false positive）。BYTE 数据关联方法具体的流程如下：

1、根据检测框得分，把检测框分为高分框和低分框，分开处理
2、第一次使用高分框和之前的跟踪轨迹进行匹配
3、第二次使用低分框和第一次没有匹配上高分框的跟踪轨迹（例如在当前帧受到严重遮挡导致得分下降的物体）进行匹配

4、对于没有匹配上跟踪轨迹，得分又足够高的检测框，我们对其新建一个跟踪轨迹。对于没有匹配上检测框的跟踪轨迹，我们会保留30帧，在其再次出现时再进行匹配。



BYTE 的工作原理可以理解为，遮挡往往伴随着检测得分由高到低的缓慢降低：被遮挡物体在被遮挡之前是可视物体，检测分数较高，建立轨迹；当物体被遮挡时，通过检测框与轨迹的位置重合度就能把遮挡的物体从低分框中挖掘出来，保持轨迹的连贯性。



ByteTrack 的检测器部分采用 YOLOX。

在数据关键的部分，和 SORT 一样，只使用卡尔曼滤波来预测当前帧的跟踪轨迹在下一帧的位置，预测的框和实际的检测框之间的 IoU 作为两次匹配时的相似度，通过匈牙利算法完成匹配。这里值得注意的是 ByteTrack 为了保证检测的实时性没有使用 ReID 特征（别的论文提到重复识别特征，我还没有了解是什么）来计算外观相似度，也就是说仅仅使用了运动模型。

算法对比：

![image-20230408113650732](4.8%E8%AF%BB%E8%AE%BA%E6%96%87.assets/image-20230408113650732.png)